5 ΦΑΣΕΙΣ:

  ΦΑΣΗ 1: Puzzle Generator (Frontend)
  ====================================
  Original image > Cut into pieces > Shuffle and Rotate

  INPUT: Εικόνα + size του grid
  1. Resize εικόνας στα 200?200 px (ή 300?300)
  2. Κοπή σε κομμάτια
     pieces = [piece0, piece1, ..., piece8]
  3. Δημιουργία ground truth:
     ground_truth: { piece_id: {sourceIndex: 0, destPosition: 0, rotation: 0} }
  4. Shuffle τα tiles και ανάμιξη
     [0,1,2,3,4,5,6,7,8] > [5,2,8,0,4,1,7,3,6]
  5. Τυχαία rotation σε κάθε piece για evaluation

  OUTPUT:
  1. Pieces[]: array με τα shuffle & rotated pieces
  2. Ground_truth: τα σωστά indices και rotations για evaluation
  3. Grid_size

  Περιγραφή: Εφαρμογή 3 blocks στο frontend.

  Block 1 - Upload Image:
  - Επιλογή είτε να ανεβάσεις δική σου εικόνα, ή default φορτώνεται το test7.jpg
  - Χρησιμοποιείται για testing
  - Εναλλακτικά test images: test4.jpg, test5.jpg, test6.jpg, test7.jpg

  Block 2 - Shuffle and Rotate:
  - Κοπή σε grid με shuffle και rotation κάθε κομματιού ξεχωριστά
  - Default grid size είναι 2?2 (ή 3?3) για testing
  - Μπορεί να επιλέξει ο χρήστης να 3?3, 4?4, κλπ

  Block 3 - Border Strips Extractor:
  - Ο χρήστης ορίζει το border width (default 5 pixels)
  - Ο χρήστης ορίζει τα histogram bins (16, 32, 64, 128, ή 256)
    * Λιγότερα bins = πιο γρήγορος υπολογισμός, αλλά λιγότερη λεπτομέρεια
    * Περισσότερα bins = πιο αργός υπολογισμός αλλά περισσότερη πληροφορία
    * Default: 16 bins
  - Μετά πατάμε "Extract Border Strips", βγαίνει preview των borders
  - Μετά πατάμε "Send to Backend", στέλνονται τα δεδομένα στο Python FastAPI backend

  BACKEND λειτουργία:
  - Δημιουργείται φάκελος "tempPhotos" στο root directory
  - Διαγράφονται όλα τα παλιά περιεχόμενα του φακέλου
  - Αποθηκεύονται όλοι οι border strips ΓΙΑ ΟΛΕΣ ΤΙΣ ROTATIONS:
    * tile_0_src0_rot0_top.jpg
    * tile_0_src0_rot0_right.jpg
    * ...
    * tile_0_src0_rot90_top.jpg
    * tile_0_src0_rot90_right.jpg
    * ...
    * tile_0_src0_rot180_top.jpg
    * ...
    * tile_0_src0_rot270_top.jpg
    * (επαναλαμβάνεται για κάθε tile ? 4 rotations ? 4 borders = 16 images ανά tile)
  - Υπολογίζονται rotation-invariant features για κάθε tile
  - Επιστρέφονται JSON results στο frontend

  ΦΑΣΗ 2: Rotation-Invariant Feature Extraction
  ==============================================
  ΣΗΜΑΝΤΙΚΗ ΑΛΛΑΓΗ (Version 4):
  Κάθε tile εξάγεται ΚΑΙ αναλύεται σε ΟΛΕΣ τις πιθανές rotations (0°, 90°, 180°, 270°).
  Αυτό επιτρέπει στο adjacency matrix να συγκρίνει πραγματικά διαφορετικές rotations.

  Κάθε tile έχεις TOP, LEFT, RIGHT, BOTTOM border strips.
  Εξάγονται 2 τύποι features:

  i) Tile-level:
     - Ολόκληρο το tile
     - Χρησιμοποιείται για global similarity

  ii) Border-level:
     - TOP, RIGHT, BOTTOM, LEFT strips
     - Χρησιμοποιείται για adjacency matching

  ΤΥΠΟΙ FEATURES:

  1. COLOR HISTOGRAMS (RGB)
  --------------------------
  - Χρησιμοποιούμε RGB color space
  - Configurable bins: 16, 32, 64, 128, ή 256
  - Υπολογίζουμε normalized histogram για κάθε κανάλι (R, G, B)
  - Εξάγεται από:
    * Ολόκληρο το tile (tile-level)
    * Κάθε border strip (top, right, bottom, left)
    * ΓΙΑ ΚΑΘΕ ROTATION (0°, 90°, 180°, 270°)

  Σημαντικό προειδοποίηση:
  - OpenCV διαβάζει εικόνες σε BGR format
  - Το backend διαχειρίζεται BGR format εσωτερικά
  - Τα histograms επιστρέφονται σε RGB σειρά για ευκολία
  - Normalization: άθροισμα = 1 για κάθε κανάλι

  2. GABOR TEXTURE FEATURES
  --------------------------
  - Εφαρμόζουμε Gabor filters για texture και edge detection
  - 4 orientations: 0°, 45°, 90°, 135°
  - 3 wavelengths (frequencies): 5, 10, 15 pixels
  - Σύνολο: 12 filters ανά region

  Παράμετροι Gabor kernel:
  - Kernel size: 31?31 pixels
  - Sigma (σ): 4.0
  - Gamma: 0.5 (spatial aspect ratio)
  - Psi: 0 (phase offset)

  Extracted features ανά filter:
  - Mean: μέση τιμή του filtered image
  - Std: standard deviation
  - Energy: άθροισμα τετραγώνων (texture strength)

  Εξάγεται από:
  - Ολόκληρο το tile (12 filters)
  - Κάθε border strip (12 filters ? 4 borders = 48 filters)
  - ΓΙΑ ΚΑΘΕ ROTATION (0°, 90°, 180°, 270°)

  Αποθήκευση:
  - Τα Gabor filtered images αποθηκεύονται στο tempPhotos/gabor_filters/
  - Format: tile_0_rot90_gabor_5.jpg
  - Χρήσιμα για debugging και visualization

  3. DEEP CNN FEATURES (MobileNetV2)
  ----------------------------------
  - Χρησιμοποιούμε MobileNetV2 pre-trained στο ImageNet
  - Lightweight architecture, κατάλληλο για real-time applications
  - Εξάγουμε features από 5 intermediate layers:

  Layer 1: block_1_expand_relu
    - Early features (56?56 spatial resolution)
    - Ανιχνεύει basic edges, colors, simple patterns

  Layer 2: block_3_expand_relu
    - Low-level textures (28?28)
    - Simple texture patterns

  Layer 3: block_6_expand_relu
    - Mid-level patterns (14?14)
    - Complex textures, shapes
    - DEFAULT layer για adjacency matrix

  Layer 4: block_13_expand_relu
    - High-level structures (7?7)
    - Object parts, complex patterns

  Layer 5: out_relu
    - Final deep features (7?7)
    - Abstract semantic features

  Feature Vector Extraction:
  - Global Average Pooling (GAP) across spatial dimensions
  - Αποτέλεσμα: compact feature vector (dimensions = number of channels)
  - Layer 1: 96 channels > 96-dimensional vector
  - Layer 5: 1280 channels > 1280-dimensional vector

  Preprocessing:
  - Resize κάθε region σε 224?224 pixels (MobileNetV2 input size)
  - BGR > RGB conversion για TensorFlow
  - MobileNetV2-specific preprocessing (normalization στο [-1, 1])

  Εξάγεται από:
  - Ολόκληρο το tile (5 layers ? feature vectors)
  - Κάθε border strip (5 layers ? 4 borders)
  - ΓΙΑ ΚΑΘΕ ROTATION (0°, 90°, 180°, 270°)

  Rotation-Invariant Feature Structure:
  -------------------------------------
  Νέα δομή δεδομένων (Version 4):

  {
    "sourceIndex": 0,
    "destPosition": 2,
    "shuffleRotation": 90,  // Η rotation από το shuffle (for reference)
    "rotationFeatures": {
      "0": {
        "tileHistogram": {"r": [...], "g": [...], "b": [...]},
        "borderHistograms": {
          "top": {...}, "right": {...}, "bottom": {...}, "left": {...}
        },
        "tileGaborFeatures": [...12 filters...],
        "borderGaborFeatures": {
          "top": [...], "right": [...], "bottom": [...], "left": [...]
        },
        "tileCnnFeatures": [...5 layers...],
        "borderCnnFeatures": {
          "top": [...], "right": [...], "bottom": [...], "left": [...]
        }
      },
      "90": { ...same structure... },
      "180": { ...same structure... },
      "270": { ...same structure... }
    }
  }

  Πλεονεκτήματα αυτής της προσέγγισης:
  - Το adjacency matrix μπορεί να συγκρίνει ΠΡΑΓΜΑΤΙΚΑ διαφορετικές rotations
  - Δεν υπάρχει semantic confusion μεταξύ "shuffle rotation" και "solver rotation"
  - Consistent absolute rotation semantics σε όλο το σύστημα
  - Καλύτερα reconstruction results

  ΦΑΣΗ 3: Adjacency Matrix με Rotation-Aware Features
  ===================================================
  Στόχος: Για κάθε δύο κομμάτια σε ΟΛΕΣ τις πιθανές rotations, υπολογίζουμε πόσο πιθανό είναι να ταιριάζουν.

  ΣΗΜΑΝΤΙΚΗ ΑΛΛΑΓΗ (Version 4):
  Το adjacency matrix τώρα συγκρίνει κάθε tile A με rotation rotA με κάθε tile B με rotation rotB.

  Υλοποίηση:
  Για κάθε tile A:
    Για κάθε rotation του A (0°, 90°, 180°, 270°):
      Για κάθε border του A (top, right, bottom, left):
        Για κάθε tile B (B ? A):
          Για κάθε rotation του B (0°, 90°, 180°, 270°):
            - Υπολογισμός opposite border (top-bottom, right-left)
            - Σύγκριση borderA με borderB
            - Υπολογισμός compatibility score

  Σύνολο συγκρίσεων για N tiles:
  - N tiles ? 4 rotations ? 4 borders ? (N-1) tiles ? 4 rotations
  - Για 2?2 grid (4 tiles): 4 ? 4 ? 4 ? 3 ? 4 = 768 comparisons
  - Για 3?3 grid (9 tiles): 9 ? 4 ? 4 ? 8 ? 4 = 4,608 comparisons

  Output Structure (ΝΕΟΣ):
  {
    "tileA": 0,
    "rotationA": 90,      // Absolute rotation του tile A
    "borderA": "right",
    "tileB": 3,
    "rotationB": 180,     // Absolute rotation του tile B
    "borderB": "left",    // Opposite border (always opposite for rotation=0)
    "compatibilityScore": 0.85,
    "scores": {
      "color": 0.82,
      "gabor": 0.88,
      "cnn": 0.85
    }
  }

  Distance Metrics:
  -----------------

  1. Chi-Square Distance (Color Histograms):
     - Χρησιμοποιείται για color histogram comparison
     - Τύπος: χ² = Σ[(h1[i] - h2[i])² / (h1[i] + h2[i] + ε)]
     - Lower is better (0 = identical)
     - Typical range: 0-2 για normalized histograms
     - Normalization: distance > similarity (1 - distance/max_distance)

  2. Euclidean Distance (Gabor Features):
     - Χρησιμοποιείται για Gabor texture features
     - L2 distance μεταξύ feature vectors
     - Lower is better (0 = identical)
     - Normalization: distance > similarity (1 - distance/max_distance)

  3. Cosine Similarity (CNN Features):
     - Χρησιμοποιείται για deep CNN features
     - Μετράει το cosine της γωνίας μεταξύ vectors
     - Τύπος: cos(θ) = (v1 · v2) / (||v1|| * ||v2||)
     - Range: 0-1 (higher is better, 1 = identical direction)
     - Ήδη similarity metric (δεν χρειάζεται normalization)

  Border Matching Logic (ΑΠΛΟΠΟΙΗΜΕΝΟΣ):
  ---------------------------------------
  Μετά τη rotation-invariant feature extraction, το matching είναι πιο απλό:
  - Συγκρίνουμε ΠΑΝΤΑ opposite borders (top-bottom, right-left)
  - Η rotation handling γίνεται από το ότι έχουμε features για όλες τις rotations
  - Δεν χρειάζεται το get_opposite_border() με rotation parameter

  Weighted Combination:
  --------------------
  Κάθε border comparison παράγει 3 scores:
  - Color score (από Chi-Square distance)
  - Gabor score (από Euclidean distance)
  - CNN score (από Cosine similarity)

  Combined Score = w_color * color_score + w_gabor * gabor_score + w_cnn * cnn_score

  Default weights: {color: 0.4, gabor: 0.3, cnn: 0.3}

  Configurable Parameters:
  - Weights για κάθε metric
  - CNN layer για comparison (default: block_6_expand_relu)
  - TopK: πόσα top matches να κρατήσουμε ανά tile-rotation-border (default: 10)

  Filtering:
  ---------
  Για κάθε combination (tileA, rotationA, borderA):
  - Κρατάμε μόνο τα TopK καλύτερα matches
  - Sorted by compatibility score (descending)
  - Μειώνει το μέγεθος του adjacency matrix
  - Επιταχύνει τους reconstruction algorithms

  Statistics:
  - Total comparisons (όλα τα δυνατά matches)
  - Filtered matches (TopK ανά tile-rotation-border)
  - Average, Min, Max, Std compatibility scores
  - Best overall match

  ΦΑΣΗ 4: Puzzle Reconstruction (Dual Algorithm Approach)
  ========================================================

  Στόχος: Αυτόματη ανακατασκευή του puzzle χρησιμοποιώντας τα compatibility scores.

  ΣΗΜΑΝΤΙΚΗ ΑΛΛΑΓΗ (Version 4):
  Τώρα υπάρχουν 2 reconstruction algorithms που τρέχουν παράλληλα για comparison:
  1. Greedy Solver (γρήγορος, local optimization)
  2. Simulated Annealing (πιο αργός, global optimization)

  Algorithm 1: Greedy Solver
  ---------------------------
  Χαρακτηριστικά:
  - Fast execution (< 1 second για 3?3 grid)
  - Deterministic results
  - Local optimization (δεν backtrack)
  - Threshold-based placement

  Λειτουργία:
  1. Ξεκινάει με Tile 0 στην θέση (0,0) με rotation=0
  2. Για κάθε κενή θέση στο grid:
     a. Ελέγχει τους γείτονες (πάνω, κάτω, αριστερά, δεξιά)
     b. Για κάθε unused tile:
        - Δοκιμάζει όλες τις rotations (0°, 90°, 180°, 270°)
        - Υπολογίζει average compatibility με γείτονες
        - Χρησιμοποιεί το adjacency matrix με rotationA και rotationB
     c. Επιλέγει το tile+rotation με το υψηλότερο avg compatibility score
     d. Τοποθετεί το tile με το rotation που προτείνεται
  3. Επαναλαμβάνει μέχρι να μην μπορεί να βρει άλλα καλά matches (threshold: 0.3)

  Placement Logic (ΕΝΗΜΕΡΩΜΕΝΟΣ):
  --------------------------------
  Για κάθε υποψήφιο tile στην θέση (row, col) με rotation candidateRotation:
  - Top neighbor (row-1, col):
    * neighborRotation = grid[row-1][col].rotation
    * Filter adjacency matrix: tileA=neighbor, rotationA=neighborRotation, borderA='bottom'
                               tileB=candidate, rotationB=candidateRotation
  - Left neighbor (row, col-1):
    * Similar logic με borderA='right'
  - Right neighbor (row, col+1):
    * Similar logic με borderA='left'
  - Bottom neighbor (row+1, col):
    * Similar logic με borderA='top'

  Avg score = (sum of border compatibilities) / (number of neighbors)

  Algorithm 2: Simulated Annealing
  ---------------------------------
  Χαρακτηριστικά:
  - Slower execution (configurable iterations: 100-5000)
  - Probabilistic results (διαφορετικά αποτελέσματα σε κάθε run)
  - Global optimization (δέχεται χειρότερες λύσεις για να αποφύγει local minima)
  - No threshold (τοποθετεί πάντα όλα τα tiles)

  Configurable Parameters:
  - Initial Temperature: 10-500 (default: 100)
  - Cooling Rate: 0.8-0.99 (default: 0.95)
  - Iterations: 100-5000 (default: 1000)

  Λειτουργία:
  1. Αρχικοποίηση: Random placement όλων των tiles με random rotations
  2. Energy Calculation:
     - Για κάθε γειτονικό ζευγάρι tiles:
     - Υπολογίζει compatibility από adjacency matrix
     - Lower energy = better configuration
     - Energy = -Σ(compatibility scores)
  3. Main Loop (iterations):
     a. Perturbation: Swap 2 random tiles ή rotate 1 random tile
     b. Calculate new energy
     c. Acceptance Criteria:
        - Αν newEnergy < currentEnergy: ΑΠΟΔΟΧΗ (πάντα)
        - Αλλιώς: ΑΠΟΔΟΧΗ με πιθανότητα exp(-ΔE/T)
     d. Temperature Cooling: T = T ? cooling_rate
     e. Track best solution ever found
  4. Return: Best configuration found

  Energy Function (ΕΝΗΜΕΡΩΜΕΝΟΣ):
  --------------------------------
  Για κάθε tile position (row, col):
  - Right neighbor compatibility:
    * matches = filter(adjacency, tileA=current, rotationA=current.rotation, borderA='right',
                                   tileB=rightTile, rotationB=rightTile.rotation)
    * energy -= bestMatch.compatibilityScore
  - Bottom neighbor compatibility:
    * Similar logic με borderA='bottom'

  Total Energy = -Σ(all neighbor compatibilities)

  Comparison Metrics:
  ------------------
  Και οι 2 algorithms εμφανίζονται side-by-side με:
  - Reconstructed image preview
  - Position Accuracy: % tiles στη σωστή θέση
  - Rotation Accuracy: % tiles με σωστό rotation
  - Winner declaration (ποιος algorithm είχε καλύτερο position accuracy)

  Accuracy Calculation (ΕΝΗΜΕΡΩΜΕΝΟΣ):
  ------------------------------------
  Για κάθε θέση (row, col):
  1. Predicted source index = histogramData.results[tileIndex].sourceIndex
  2. Correct source index = row ? gridSize + col
  3. Position correct: predicted == correct
  4. Rotation correct: predicted.rotation == 0 (αρχική εικόνα χωρίς rotation)

  Σημείωση: Το rotation check είναι απλό τώρα γιατί χρησιμοποιούμε absolute rotations.

  Drawing Reconstructed Image (ΕΝΗΜΕΡΩΜΕΝΟΣ):
  -------------------------------------------
  Για κάθε tile στο reconstructed grid:
  1. Παίρνουμε το sourceIndex από το histogramData
  2. Υπολογίζουμε source position (sourceRow, sourceCol)
  3. Σχεδιάζουμε το tile από την ΑΡΧΙΚΗ εικόνα (χωρίς shuffle rotation)
  4. Εφαρμόζουμε ΜΟΝΟ το rotation από τον solver (absolute rotation)
  5. Canvas rotation: rotationRadians = (cell.rotation ? π) / 180

  Limitations του Greedy:
  -----------------------
  - Local decisions (όχι global optimization)
  - Δεν backtrack αν κάνει λάθος επιλογή
  - Threshold-based placement (μπορεί να μείνουν tiles unplaced)
  - Εξαρτάται από το starting tile

  Advantages του Simulated Annealing:
  -----------------------------------
  - Αποφεύγει local minima με probabilistic acceptance
  - Explores global search space
  - Βρίσκει συνήθως καλύτερες λύσεις από Greedy
  - Tunable parameters για balance μεταξύ quality/speed

  Disadvantages του Simulated Annealing:
  --------------------------------------
  - Πιο αργός (ειδικά με πολλά iterations)
  - Non-deterministic (διαφορετικά results κάθε φορά)
  - Χρειάζεται tuning των parameters
  - Μπορεί να κολλήσει σε local minima με κακά parameters

  FRONTEND COMPONENTS (ΕΝΗΜΕΡΩΜΕΝΑ)
  ==================================

  1. UploadImage.jsx
     - File upload ή χρήση default εικόνας (test7.jpg)
     - Preview της εικόνας
     - Hardcoded default: /test7.jpg

  2. ShuffleAndRotateImage.jsx
     - Grid size selection (2?2, 3?3, 4?4, κλπ)
     - Shuffle και rotation των tiles
     - Δημιουργία shuffleData για App context

  3. BorderStripsExtractor.jsx
     - Border width input (1-50 pixels, default: 5)
     - Bins selection (16, 32, 64, 128, 256, default: 16)
     - Extract border strips preview
     - Send to Backend button
     - Δημιουργία histogramData για App context
     - ΝΕΟΣ: Υπολογισμός features για 4 rotations ? N tiles

  4. ColorHistogram.jsx (ΕΝΗΜΕΡΩΜΕΝΟΣ)
     - ΝΕΟΣ: Dropdown για επιλογή rotation (0°, 90°, 180°, 270°)
     - Εμφάνιση color histograms (R, G, B)
     - Tile-level και Border-level views
     - Table format με normalized values
     - Επιλογή tile για εξέταση
     - Access: rotationFeatures[selectedRotation]

  5. GaborFeatures.jsx (ΕΝΗΜΕΡΩΜΕΝΟΣ)
     - ΝΕΟΣ: Dropdown για επιλογή rotation (0°, 90°, 180°, 270°)
     - Εμφάνιση Gabor texture features
     - 12 filters ανά region (4 orientations ? 3 wavelengths)
     - Tile-level και Border-level views
     - Statistics: orientation, wavelength, mean, std, energy
     - Access: rotationFeatures[selectedRotation]

  6. CnnFeatures.jsx (ΕΝΗΜΕΡΩΜΕΝΟΣ)
     - ΝΕΟΣ: Dropdown για επιλογή rotation (0°, 90°, 180°, 270°)
     - Εμφάνιση Deep CNN features από MobileNetV2
     - 5 intermediate layers
     - Tile-level και Border-level views
     - Layer information: shape, channels, mean, std, min, max
     - Feature vector preview (first 20 values)
     - Full features στο console
     - Access: rotationFeatures[selectedRotation]

  7. AdjacencyMatrixViewer.jsx (ΕΝΗΜΕΡΩΜΕΝΟΣ)
     - Configuration panel:
       * Feature weights (color, gabor, cnn)
       * CNN layer selection
       * TopK selection
     - ΝΕΟΣ: Error checking για old data structure
     - View modes:
       * Statistics: Overall metrics και best match
       * Best Matches: Top matches ανά tile-rotation-border
       * Heatmap: Visual representation of compatibility
     - Saves adjacencyData to App context για ImageReconstruction
     - Δεν περιλαμβάνει πια το Reconstruction view (μεταφέρθηκε σε ξεχωριστό component)

  8. ImageReconstruction.jsx (ΝΕΟΣ COMPONENT - Version 4)
     --------------------------------------------------------
     Dual-Algorithm Comparison Interface

     Features:
     - Side-by-side comparison: Greedy vs Simulated Annealing
     - Configurable Simulated Annealing parameters:
       * Initial Temperature slider (10-500)
       * Cooling Rate slider (0.8-0.99)
       * Iterations slider (100-5000)
     - Real-time reconstruction preview (2 canvases)
     - Accuracy comparison table:
       * Position Accuracy (%)
       * Rotation Accuracy (%)
       * Winner declaration
     - Original image display
     - Shuffled image display
     - Algorithm explanations
     - ΑΦΑΙΡΕΘΗΚΑΝ: Red/Green borders (καθαρή εικόνα preview)

     Dependencies:
     - Χρειάζεται: file, shuffleData, adjacencyData, histogramData από App context
     - Validation: Ελέγχει ότι όλα τα απαραίτητα data υπάρχουν πριν render

     Workflow:
     1. User clicks "Run Greedy Solver" > greedyGrid, greedyAccuracy
     2. User adjusts parameters και clicks "Run Simulated Annealing" > annealingGrid, annealingAccuracy
     3. Side-by-side comparison με winner highlight
     4. Μπορεί να τρέξει ξανά με διαφορετικά parameters

  BACKEND (FastAPI) - ΕΝΗΜΕΡΩΜΕΝΟΣ
  =================================

  Endpoint: POST /api/calculate-histograms (ΕΝΗΜΕΡΩΜΕΝΟΣ)
  --------------------------------------------------------

  ΣΗΜΑΝΤΙΚΗ ΑΛΛΑΓΗ: Τώρα υπολογίζει features για ΟΛΕΣ τις rotations.

  Input Parameters:
  - image: UploadFile (το uploaded image)
  - gridSize: int (π.χ. 2 για 2?2)
  - borderWidth: int (pixels)
  - bins: int (16, 32, 64, 128, ή 256)
  - tiles: JSON string με [{sourceIndex, destPosition, rotation}, ...]

  Λειτουργία (ΝΕΟΣ):
  1. Διάβασμα εικόνας με OpenCV (BGR format)
  2. Για κάθε tile:
     a. Loop για κάθε rotation angle (0, 90, 180, 270):
        - Εξαγωγή tile από source position
        - Περιστροφή tile με cv2.rotate() σε rotation_angle
        - Εξαγωγή 4 border strips
        - Υπολογισμός features:
          * Color Histogram (RGB, configurable bins)
          * Gabor Filters (12 filters)
          * CNN Features (MobileNetV2, 5 layers)
        - Αποθήκευση border strip images: tile_X_rotY_border.jpg
        - Αποθήκευση Gabor images: tile_X_rotY_gabor_Z.jpg
        - Αποθήκευση features στο rotationFeatures[str(rotation_angle)]
     b. Aggregation: όλα τα rotationFeatures σε ένα tile object

  Output JSON (ΝΕΟΣ):
  {
    "status": "success",
    "gridSize": 2,
    "borderWidth": 5,
    "bins": 16,
    "totalTiles": 4,
    "totalRotations": 4,  // ΝΕΟ FIELD
    "totalImages": 64,    // 4 tiles ? 4 rotations ? 4 borders = 64
    "message": "Calculated rotation-invariant features for 4 tiles (4 rotations each). Saved 64 border strip images to tempPhotos/",
    "results": [
      {
        "sourceIndex": 0,
        "destPosition": 2,
        "shuffleRotation": 90,  // ΝΕΟ: Η rotation από το shuffle
        "rotationFeatures": {   // ΝΕΟ: Dictionary με features ανά rotation
          "0": {
            "tileHistogram": {"r": [...], "g": [...], "b": [...]},
            "borderHistograms": {
              "top": {"r": [...], "g": [...], "b": [...]},
              "right": {...},
              "bottom": {...},
              "left": {...}
            },
            "tileGaborFeatures": [...12 filters...],
            "borderGaborFeatures": {
              "top": [...12 filters...],
              "right": [...12 filters...],
              "bottom": [...12 filters...],
              "left": [...12 filters...]
            },
            "tileCnnFeatures": [...5 layers...],
            "borderCnnFeatures": {
              "top": [...5 layers...],
              "right": [...5 layers...],
              "bottom": [...5 layers...],
              "left": [...5 layers...]
            }
          },
          "90": { ...ίδια δομή... },
          "180": { ...ίδια δομή... },
          "270": { ...ίδια δομή... }
        }
      },
      ...για κάθε tile
    ]
  }

  Performance Impact:
  - 4? περισσότερα features υπολογίζονται
  - 4? περισσότερες εικόνες αποθηκεύονται
  - Για 3?3 grid: ~5-10 seconds (depends on CPU/GPU)
  - Για 4?4 grid: ~20-40 seconds
  - Optimizations: CNN features caching, parallel processing

  Endpoint: POST /api/calculate-adjacency-matrix (ΕΝΗΜΕΡΩΜΕΝΟΣ)
  --------------------------------------------------------------

  ΣΗΜΑΝΤΙΚΗ ΑΛΛΑΓΗ: Συγκρίνει κάθε rotation του A με κάθε rotation του B.

  Input JSON (ίδιο):
  {
    "histogramData": dict (full response από /api/calculate-histograms),
    "weights": dict (optional, default: {"color": 0.4, "gabor": 0.3, "cnn": 0.3}),
    "cnnLayer": str (optional, default: "block_6_expand_relu"),
    "topK": int (optional, default: 10)
  }

  Validation (ΝΕΟ):
  - Ελέγχει αν histogramData έχει νέα δομή με 'rotationFeatures'
  - Αν όχι, επιστρέφει error: "Histogram data has old structure. Please recalculate histograms!"

  Λειτουργία (ΝΕΟΣ):
  1. Για κάθε tile A:
     a. Για κάθε rotation του A ('0', '90', '180', '270'):  // String keys!
        - Για κάθε border του A (top, right, bottom, left):
          * Παίρνει features: tileA.rotationFeatures[rotA].borderHistograms[borderA]
          - Για κάθε tile B (B ? A):
            * Για κάθε rotation του B ('0', '90', '180', '270'):
              - Υπολογίζει opposite border (always opposite για consistency)
              - Παίρνει features: tileB.rotationFeatures[rotB].borderHistograms[borderB]
              - Υπολογισμός compatibility με 3 metrics
              - Weighted combination
              - Αποθήκευση match: {tileA, rotationA (int), borderA, tileB, rotationB (int), borderB, score}
  2. Sort όλα τα matches by compatibility score (descending)
  3. Filter: κράτα TopK matches ανά (tileA, rotationA, borderA) combination
  4. Υπολογισμός statistics

  Output JSON (ΝΕΟΣ):
  {
    "status": "success",
    "gridSize": 2,
    "totalTiles": 4,
    "weights": {"color": 0.4, "gabor": 0.3, "cnn": 0.3},
    "cnnLayer": "block_6_expand_relu",
    "topK": 10,
    "adjacencyMatrix": [
      {
        "tileA": 0,
        "rotationA": 90,       // ΝΕΟ: Absolute rotation του tile A
        "borderA": "right",
        "tileB": 3,
        "rotationB": 180,      // ΝΕΟ: Absolute rotation του tile B
        "borderB": "left",
        "compatibilityScore": 0.85,
        "scores": {"color": 0.82, "gabor": 0.88, "cnn": 0.85}
      },
      ...
    ],
    "statistics": {
      "totalComparisons": 768,      // 4 tiles ? 4 rot ? 4 borders ? 3 tiles ? 4 rot
      "filteredMatches": 640,       // 4 tiles ? 4 rot ? 4 borders ? 10 topK
      "averageCompatibility": 0.52,
      "minCompatibility": 0.12,
      "maxCompatibility": 0.94,
      "stdCompatibility": 0.18,
      "bestMatch": {...}
    }
  }

  Key Implementation Details:
  - String keys για rotationFeatures στο Python dict (JSON compatibility)
  - Convert σε int για rotationA/rotationB στο output (frontend expects integers)
  - Opposite borders mapping: {top: bottom, right: left, bottom: top, left: right}
  - No get_opposite_border(rotation) logic needed (απλοποιήθηκε)

  TESTING και VALIDATION (ΕΝΗΜΕΡΩΜΕΝΟΣ)
  ======================================

  Test Workflow (Updated):
  ------------------------
  1. Upload test image (test7.jpg ή custom)
  2. Shuffle με grid size (default: 2?2 ή 3?3)
  3. Set border width (default: 5px) και bins (default: 16)
  4. Click "Send to Backend"
     - Υπολογισμός rotation-invariant features
     - Αναμονή: ~5-10 seconds για 3?3 grid
     - Επιβεβαίωση: "Calculated rotation-invariant features for X tiles"
  5. Browse features στα 3 components (με rotation dropdown)
  6. Configure adjacency matrix parameters
  7. Click "Calculate Adjacency Matrix"
     - Υπολογισμός compatibility scores
     - Αναμονή: ~2-5 seconds για 3?3 grid
     - Επιβεβαίωση: "Success! Calculated X comparisons, filtered to Y top matches"
  8. Navigate to Image Reconstruction tab
  9. Click "Run Greedy Solver" > instant results
  10. Adjust Simulated Annealing parameters
  11. Click "Run Simulated Annealing" > results after iterations complete
  12. Compare accuracy scores

  Validation Points:
  -----------------
  ? Rotation dropdown works σε Color/Gabor/CNN components
  ? Features διαφοροποιούνται ανάμεσα σε rotations
  ? Adjacency matrix contains rotationA και rotationB
  ? Greedy solver completes και παράγει grid
  ? Simulated Annealing completes και παράγει grid
  ? Accuracy metrics computed correctly
  ? Winner declared based on position accuracy
  ? Reconstructed images render χωρίς borders

  Expected Results για 2?2 Grid:
  -----------------------------
  - Total comparisons: ~768
  - Filtered matches: ~640 (με topK=10)
  - Best compatibility score: > 0.8 για καλή εικόνα
  - Greedy position accuracy: 25-75% (depends on image complexity)
  - Annealing position accuracy: 50-100% (με καλά parameters)

  Performance Benchmarks:
  ----------------------
  Hardware: Average laptop (Intel i5, 8GB RAM, no GPU)

  2?2 Grid (4 tiles):
  - Feature extraction: ~2-3 seconds
  - Adjacency matrix: ~1 second
  - Greedy solver: < 0.5 seconds
  - Simulated Annealing (1000 iterations): ~2-3 seconds

  3?3 Grid (9 tiles):
  - Feature extraction: ~8-12 seconds
  - Adjacency matrix: ~3-5 seconds
  - Greedy solver: ~1 second
  - Simulated Annealing (1000 iterations): ~10-15 seconds

  4?4 Grid (16 tiles):
  - Feature extraction: ~30-40 seconds
  - Adjacency matrix: ~15-25 seconds
  - Greedy solver: ~2-3 seconds
  - Simulated Annealing (1000 iterations): ~40-60 seconds

  Optimization Recommendations:
  ----------------------------
  1. GPU acceleration για CNN features (TensorFlow GPU)
  2. Parallel processing για rotation loop
  3. Feature caching για repeated calculations
  4. Reduce TopK για faster adjacency matrix
  5. Reduce iterations για faster Simulated Annealing
  6. Use smaller bins (16 instead of 256)

  Επεκτάσεις και Βελτιώσεις
  =========================

  Υλοποιημένα (Version 4):
  1. ? Color Histogram features (RGB, configurable bins)
  2. ? Gabor Texture features (12 filters)
  3. ? Deep CNN features (MobileNetV2, 5 layers)
  4. ? Rotation-invariant feature extraction (4 rotations ανά tile)
  5. ? Adjacency Matrix με rotation-aware features
  6. ? Border matching με absolute rotations
  7. ? Greedy Puzzle Solver
  8. ? Simulated Annealing Solver
  9. ? Dual-algorithm comparison interface
  10. ? Heatmap visualization
  11. ? Accuracy metrics (position & rotation)
  12. ? Rotation selection dropdown σε visualization components
  13. ? Error handling για old data structure

  Προτεινόμενες βελτιώσεις για Version 5:
  1. Additional solvers:
     - Genetic Algorithm
     - Ant Colony Optimization
     - A* Search
     - Constraint Satisfaction Problem (CSP)

  2. Performance optimizations:
     - GPU acceleration για CNN features
     - Parallel processing για rotation loop
     - Feature caching mechanism
     - Lazy loading για large grids

  3. Advanced features:
     - Corner piece detection (ανίχνευση γωνιών)
     - Edge piece detection (ανίχνευση ακμών)
     - Progressive refinement (multi-scale approach)
     - Confidence scores ανά placement

  4. User experience:
     - Real-time reconstruction visualization (animation)
     - Manual tile adjustment (drag & drop)
     - Undo/Redo functionality
     - Save/Load reconstruction state
     - Export reconstruction as image

  5. Analysis tools:
     - Feature importance analysis
     - Weight optimization (machine learning)
     - Confusion matrix για placements
     - Per-tile accuracy breakdown

  6. Additional metrics:
     - SSIM (Structural Similarity Index)
     - Edge continuity score
     - Color gradient continuity
     - Texture consistency score

  7. Batch processing:
     - Multiple image processing
     - Automatic parameter tuning
     - Benchmark suite για algorithm comparison

  8. Visualization enhancements:
     - 3D rotation preview
     - Animation of Simulated Annealing process
     - Heatmap για placement confidence
     - Timeline slider για reconstruction steps

  Τεχνικό Χρέος και Known Issues:
  -------------------------------
  1. Memory usage: 4? increase λόγω rotation-invariant features
     - Μπορεί να προκαλέσει issues σε large grids (> 5?5)
     - Πρόταση: Lazy loading ή on-demand feature calculation

  2. Frontend performance: Large adjacency matrices slow down rendering
     - Πρόταση: Virtualization για large tables

  3. Simulated Annealing non-determinism:
     - Διαφορετικά results σε κάθε run
     - Πρόταση: Seed parameter για reproducibility

  4. Greedy threshold sensitivity:
     - Hard-coded threshold (0.3) μπορεί να μην είναι optimal
     - Πρόταση: Dynamic threshold based on statistics

  5. Rotation semantics complexity:
     - Confusion μεταξύ "shuffle rotation" και "solver rotation" (ΛΥΘΗΚΕ στην V4)
     - Canvas rotation logic (ΑΠΛΟΠΟΙΗΘΗΚΕ στην V4)

  Οδηγίες για Εκτέλεση
  =========================

  Backend:
  1. cd backend
  2. python -m venv venv (αν δεν υπάρχει)
  3. venv\Scripts\activate (Windows) ή source venv/bin/activate (Mac/Linux)
  4. pip install -r requirements.txt
  5. uvicorn app:app --reload
  6. Το backend στο http://localhost:8000

  Frontend:
  1. cd frontend
  2. npm install
  3. npm run dev
  4. Το frontend στο http://localhost:5173

  Dependencies:
  - Backend: fastapi, uvicorn, opencv-python, numpy, pillow, tensorflow
  - Frontend: react, vite

  Σημειώσεις:
  - Το MobileNetV2 κατεβαίνει automatically την πρώτη φορά (~14MB)
  - Το tempPhotos/ δημιουργείται automatically και καθαρίζεται κάθε run
  - Όλα τα features επιστρέφονται σε JSON format για εύκολη επεξεργασία
  - Τα rotation keys στα Python dicts είναι strings ("0", "90", "180", "270")
  - Τα rotation values στα responses είναι integers (0, 90, 180, 270)

  Troubleshooting:
  ---------------
  1. Error: "Histogram data has old structure"
     - Solution: Κάνε πάλι "Send to Backend" για να υπολογιστούν τα νέα features

  2. Frontend shows "undefined" για features
     - Solution: Βεβαιώσου ότι χρησιμοποιείς String(selectedRotation) για access

  3. Adjacency matrix calculation very slow
     - Solution: Μείωσε το TopK ή χρησιμοποίησε μικρότερο grid

  4. Simulated Annealing δεν τελειώνει
     - Solution: Μείωσε τα iterations ή check το console για errors

  5. Images not saving to tempPhotos
     - Solution: Check permissions για το root directory

  Ιστορικό Εκδόσεων
  ==================

  Version 1:
  - Βασική υποδομή: upload, shuffle, border extraction
  - Αποθήκευση border strip images

  Version 2:
  - Προσθήκη Color Histograms (RGB με configurable bins)
  - Fix BGR/RGB bug
  - Προσθήκη Gabor Texture Features (12 filters)
  - Προσθήκη Deep CNN Features (MobileNetV2, 5 layers)
  - Δημιουργία 3 visualization components
  - Default bins: 16 για ταχύτερη επεξεργασία

  Version 3:
  - Προσθήκη Adjacency Matrix calculation
  - Distance metrics: Chi-Square, Euclidean, Cosine Similarity
  - Border matching logic με rotation handling
  - Greedy Puzzle Solver algorithm
  - Heatmap visualization
  - Reconstruction view με accuracy metrics
  - Interactive configuration (weights, CNN layer, TopK)
  - Statistics και best matches display
  - Ground truth comparison

  Version 4 (τρέχουσα):
  - **BREAKING CHANGE**: Rotation-invariant feature extraction
    * Features υπολογίζονται για όλες τις rotations (0°, 90°, 180°, 270°)
    * Νέα δομή: rotationFeatures dictionary
    * 4? περισσότερα features, καλύτερη ακρίβεια

  - **Adjacency Matrix Redesign**:
    * Absolute rotation semantics (rotationA, rotationB)
    * Συγκρίνει κάθε rotation του A με κάθε rotation του B
    * Απλοποιημένο border matching logic
    * String keys για Python dicts, int values για responses

  - **Dual Reconstruction Algorithms**:
    * Greedy Solver (fast, deterministic)
    * Simulated Annealing (slow, probabilistic, better results)
    * Side-by-side comparison interface
    * Configurable parameters για Simulated Annealing
    * Winner declaration based on accuracy

  - **Enhanced Visualization**:
    * Rotation dropdown σε Color/Gabor/CNN components
    * Καθαρή εικόνα preview (χωρίς red/green borders)
    * Improved accuracy metrics display
    * Algorithm explanation panels

  - **Bug Fixes**:
    * Rotation semantic consistency (ΜΕΓΑΛΗ ΔΙΟΡΘΩΣΗ)
    * Canvas rotation logic simplification
    * Error handling για old data structure
    * Frontend component data structure updates

  - **Performance**:
    * Backend validation για data structure
    * Optimized feature extraction loop
    * Better error messages

  Architectural Improvements (Version 4):
  --------------------------------------
  1. **Separation of Concerns**:
     - Feature extraction (rotation-invariant)
     - Adjacency calculation (rotation-aware)
     - Reconstruction (absolute rotations)

  2. **Data Flow Consistency**:
     - Backend > rotationFeatures dictionary
     - Adjacency > rotationA, rotationB integers
     - Solver > absolute rotation integers
     - Accuracy > simple 0° check

  3. **Semantic Clarity**:
     - shuffleRotation: για reference μόνο
     - rotationA/rotationB: για adjacency matching
     - solver rotation: για reconstruction
     - Όλα absolute (0°, 90°, 180°, 270°)

  Future Roadmap (Version 5+):
  ---------------------------
  1. Machine Learning Integration:
     - Learn optimal weights από training data
     - Neural network για direct puzzle solving
     - Transfer learning από pre-trained models

  2. Advanced Algorithms:
     - Genetic Algorithm implementation
     - Ant Colony Optimization
     - Hybrid approaches (Greedy + Annealing)

  3. Scalability:
     - Support για πολύ μεγάλα grids (10?10+)
     - Distributed processing
     - Cloud deployment

  4. User Features:
     - Manual editing mode
     - Collaborative solving
     - Puzzle generation tools
     - Educational mode με step-by-step explanation

  Συμπεράσματα
  ============

  Το AnalyshEikonas project είναι ένα ολοκληρωμένο σύστημα για image puzzle analysis και reconstruction.
  Η Version 4 αντιμετωπίζει τα κύρια architectural issues της Version 3 και προσθέτει σημαντικές βελτιώσεις:

  Βασικά Achievements:
  1. ? Rotation-invariant features > καλύτερη matching accuracy
  2. ? Dual algorithms > comparison και validation
  3. ? Consistent semantics > εύκολη maintenance
  4. ? Clean architecture > extensibility

  Μαθήματα από την ανάπτυξη:
  1. Rotation handling είναι complex - χρειάζεται consistent semantics σε όλο το pipeline
  2. Feature extraction για πολλαπλές rotations αυξάνει σημαντικά την ακρίβεια αλλά και το computational cost
  3. Dual algorithm approach επιτρέπει comparison και validation
  4. User interface clarity είναι κρίσιμη για complex systems